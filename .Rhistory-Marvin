are_mgnetList <- all(map_lgl(mgnets, is_mgnetList))
if (isFALSE(are_mgnet) & isFALSE(are_mgnetList)) {
stop("Error: All elements must be 'mgnet' or 'mgnetList'.")
}
new_mgnet <- new("mgnet")
# Merge each slot using the provided functions or leave them as NULL
if(!is.null(abun)){
new_mgnet@abun <- purrr::map(mgnets, \(x) mgnet::abun(x, .fmt = "df")) %>%
purrr::reduce(abun) %>%
as.matrix()
}
if(!is.null(rela)){
new_mgnet@rela <- purrr::map(mgnets, \(x) mgnet::rela(x, .fmt = "df")) %>%
purrr::reduce(rela) %>%
as.matrix()
}
if(!is.null(norm)){
new_mgnet@norm <- purrr::map(mgnets, \(x) mgnet::norm(x, .fmt = "df")) %>%
purrr::reduce(norm) %>%
as.matrix()
}
if(!is.null(meta)){
new_mgnet@meta <- purrr::map(mgnets, \(x) mgnet::meta(x)) %>%
purrr::reduce(meta)
}
if(!is.null(taxa)){
new_mgnet@taxa <- purrr::map(mgnets, \(x) mgnet::taxa(x)) %>%
purrr::reduce(norm)
}
if(!is.null(netw)){
new_mgnet@netw <- purrr::map(mgnets, \(x) mgnet::netw(x)) %>%
purrr::reduce(netw)
}
if(!is.null(comm)){
new_mgnet@comm <- purrr::map(mgnets, \(x) mgnet::comm(x)) %>%
purrr::reduce(comm)
}
validObject(new_mgnet)
return(new_mgnet)
}
merge_mgnets(mgnets[[1]],mgnets[[2]] , function(x) {
dplyr::bind_rows(x) %>%
dplyr::mutate(across(everything(), ~ dplyr::coalesce(., 0)))  # Replace NA with 0
})
isFALSE(are_mgnet)
isFALSE(are_mgnetList)
isFALSE(are_mgnet) & isFALSE(are_mgnetList)
#' Merge Multiple mgnet Objects
#'
#' @description
#' Combines multiple `mgnet` objects into a single `mgnet` object by merging their respective slots
#' according to user-specified functions. Each slot can be combined in a user-defined way because it
#' is impossible to predict how two different `mgnet` objects should be merged by default. This method
#' provides flexibility to define how each slot is combined, ensuring proper handling of the data.
#'
#' @param ... `mgnet` objects to be merged.
#' @param abun A function to merge the 'abun' slots from the provided `mgnet` objects, or `NULL` if
#'        no merging is required for this slot.
#' @param rela A function to merge the 'rela' slots from the provided `mgnet` objects, or `NULL` if
#'        no merging is required for this slot.
#' @param norm A function to merge the 'norm' slots from the provided `mgnet` objects, or `NULL` if
#'        no merging is required for this slot.
#' @param meta A function to merge the 'meta' slots from the provided `mgnet` objects, or `NULL` if
#'        no merging is required for this slot.
#' @param taxa A function to merge the 'taxa' slots from the provided `mgnet` objects, or `NULL` if
#'        no merging is required for this slot.
#' @param netw A function to merge the 'netw' slots from the provided `mgnet` objects, or `NULL` if
#'        no merging is required for this slot.
#' @param comm A function to merge the 'comm' slots from the provided `mgnet` objects, or `NULL` if
#'        no merging is required for this slot.
#'
#' @return A new `mgnet` object containing the merged data from the input objects. Each slot of the
#'         returned object is either the result of the merging function applied to that slot or `NULL`
#'         if no function was specified.
#'
#' @details
#' This method allows the user to choose how to combine the slots from different `mgnet` objects
#' because it's impossible to determine a universal rule for merging the slots. For instance, abundance
#' matrices may be row-bound using `rbind`, metadata can be merged using `dplyr::bind_rows`, and
#' network structures might be combined using `igraph::union` or another graph operation.
#'
#' Each slot (abun, rela, norm, meta, taxa, netw, comm) can be merged using a specific
#' user-defined function. If no function is provided for a particular slot,
#' the slot will remain empty in the resulting `mgnet` object. This approach provides maximum flexibility
#' in handling different types of data stored within `mgnet` objects.
#'
#' @importFrom methods new
#' @importFrom purrr map reduce
#' @export
merge_mgnets <- function(...,
abun = NULL, rela = NULL, norm = NULL,
meta = NULL, taxa = NULL,
netw = NULL, comm = NULL) {
# Flatten input to handle lists of mgnet objects or mgnetList
mgnets <- purrr::list_flatten(list(...))
if(length(mgnets) <= 1) return(mgnets)
# Check for non-mgnet objects and stop execution if found
are_mgnet     <- all(map_lgl(mgnets, is_mgnet))
are_mgnetList <- all(map_lgl(mgnets, is_mgnetList))
if (isFALSE(are_mgnet) & isFALSE(are_mgnetList)) {
stop("Error: All elements must be 'mgnet' or 'mgnetList'.")
}
new_mgnet <- new("mgnet")
# Merge each slot using the provided functions or leave them as NULL
if(!is.null(abun)){
new_mgnet@abun <- purrr::map(mgnets, \(x) mgnet::abun(x, .fmt = "df")) %>%
purrr::reduce(abun) %>%
as.matrix()
}
if(!is.null(rela)){
new_mgnet@rela <- purrr::map(mgnets, \(x) mgnet::rela(x, .fmt = "df")) %>%
purrr::reduce(rela) %>%
as.matrix()
}
if(!is.null(norm)){
new_mgnet@norm <- purrr::map(mgnets, \(x) mgnet::norm(x, .fmt = "df")) %>%
purrr::reduce(norm) %>%
as.matrix()
}
if(!is.null(meta)){
new_mgnet@meta <- purrr::map(mgnets, \(x) mgnet::meta(x)) %>%
purrr::reduce(meta)
}
if(!is.null(taxa)){
new_mgnet@taxa <- purrr::map(mgnets, \(x) mgnet::taxa(x)) %>%
purrr::reduce(norm)
}
if(!is.null(netw)){
new_mgnet@netw <- purrr::map(mgnets, \(x) mgnet::netw(x)) %>%
purrr::reduce(netw)
}
if(!is.null(comm)){
new_mgnet@comm <- purrr::map(mgnets, \(x) mgnet::comm(x)) %>%
purrr::reduce(comm)
}
validObject(new_mgnet)
return(new_mgnet)
}
merge_mgnets(mgnets[[1]],mgnets[[2]])
merge_mgnets(mgnets[[1]],mgnets[[2]], abun = bind_rows())
merge_mgnets(mgnets[[1]],mgnets[[2]], abun = bind_rows)
merge_mgnets(mgnets[[1]],mgnets[[2]],
abun = \(x) bind_rows(x) %>%
mutate(across(everything(), ~ dplyr::coalesce(., 0))))
merge_mgnets(mgnets[[1]],mgnets[[2]],
abun = \(x) bind_rows(x))
merge_mgnets(mgnets[[1]],mgnets[[2]],
abun = \(x, y) bind_rows(x, y))
merge_mgnets(mgnets[[1]],mgnets[[2]],
abun = \(x, y) bind_rows(x, y) %>%
dplyr::mutate_all(~ tidyr::replace_na(., 0)))
merge_mgnets(mgnets[[1]],mgnets[[2]],
abun = \(x, y) bind_rows(x, y) %>%
mutate_all(~ replace_na(., 0)))
merge_mgnets(mgnets[[1]],mgnets[[2]],
abun = \(x, y) bind_rows(x, y) %>%
mutate_all(replace_na(., 0)))
merge_mgnets(mgnets[[1]],mgnets[[2]],
abun = \(x, y) bind_rows(x, y) %>%
mutate_all(~ replace_na(., 0)))
merge_mgnets(mgnets,
abun = \(x, y) bind_rows(x, y) %>%
mutate_all(~ replace_na(., 0)))
purrr::map(mgnets, function(x) names(mgnets))
mgnets <- list(subjects_HMP2_netw, subjects_HMP2_netw)
purrr::map(mgnets, function(x) names(mgnets))
mgnets
names_list <- purrr::map(mgnets, names)
names_list
are_names_equal <- purrr::reduce(names_list, function(a, b) identical(a, b))
are_names_equal
if (!are_names_equal) {
stop("Error: The mgnetList objects have different names in the 'mgnets' slot.")
}
library(mgnet)
library(igraph)
help("list.edge.attributes")
helpl(is_weighted)
help(is_weighted)
net <- netw(subject_HMP2_netw)
net
# Extract edge list with weights
net <- netw(object)
edges_df <- igraph::get.data.frame(net, what = "edges")
View(edges_df)
edges_df <- igraph::as_data_frame(net, what = "edges")
View(edges_df)
edges_df <- igraph::as_data_frame(net, what = "edges")
# If the network has weights, include them
if ("weight" %in% igraph::is_weighted(net)) {
edges_df$weight <- igraph::E(net)$weight
}
# Check if the network is directed
directed <- igraph::is.directed(net)
if(!directed){
colnames(edges_df)[1:2] <- c("node1", "node2")
suffixes <- c("_1", "_2")
} else {
suffixes <- c("_from", "_to")
}
taxa_info <- taxa(object, .fmt="tbl")
object <- subject_HMP2_netw
# Ensure the network is available
if (is.null(object@netw)) {
stop("The mgnet object does not contain a network.")
}
# Extract edge list with weights
net <- netw(object)
edges_df <- igraph::as_data_frame(net, what = "edges")
# If the network has weights, include them
if ("weight" %in% igraph::is_weighted(net)) {
edges_df$weight <- igraph::E(net)$weight
}
# Check if the network is directed
directed <- igraph::is.directed(net)
if(!directed){
colnames(edges_df)[1:2] <- c("node1", "node2")
suffixes <- c("_1", "_2")
} else {
suffixes <- c("_from", "_to")
}
# Merge with taxa metadata
if(length(taxa(object)) != 0){
taxa_info <- taxa(object, .fmt="tbl")
edges_df <- edges_df %>%
left_join(taxa_info, by = c("from" = "taxa_id")) %>%
left_join(taxa_info, by = c("to" = "taxa_id"), suffix = suffixes)
}
help("left_join")
if_else(directed, "from", "node1")
taxa_info <- taxa(object, .fmt="tbl")
edges_df <- edges_df %>%
left_join(taxa_info, by = c(if_else(directed, "from", "node1") = "taxa_id"))
net <- netw(object)
edges_df <- igraph::as_data_frame(net, what = "edges")
# If the network has weights, include them
if ("weight" %in% igraph::is_weighted(net)) {
edges_df$weight <- igraph::E(net)$weight
}
# Merge with taxa metadata
if(length(taxa(object)) != 0){
taxa_info <- taxa(object, .fmt="tbl")
edges_df <- edges_df %>%
left_join(taxa_info, by = c("from" = "taxa_id")) %>%
left_join(taxa_info, by = c("to" = "taxa_id"), suffix = c(".from", ".to"))
}
View(taxa_info)
setNames(taxa(object, "tbl"))
taxa(object, "tbl")
help(paste0)
# Ensure the network is available
if (is.null(object@netw)) {
stop("The mgnet object does not contain a network.")
}
# Extract edge list with weights
net <- netw(object)
edges_df <- igraph::as_data_frame(net, what = "edges")
# If the network has weights, include them
if ("weight" %in% igraph::is_weighted(net)) {
edges_df$weight <- igraph::E(net)$weight
}
taxa_info <- taxa(object, .fmt = "tbl")
colnames(taxa_info) <- paste0(colnames(taxa_info), "_from")
taxa_info
edges_df %>%
left_join(taxa_info, by = c("from" = "taxa_id_from"))
substr(colnames(taxa_info), -4)
substr(colnames(taxa_info), 1, -4)
colnames(taxa_info)
str_sub(colnames(taxa_info), end = -4)
str_sub(colnames(taxa_info), end = -6)
colnames(edges_df)[1:2] <- c("node1", "node2")
taxa_info <- taxa(object, .fmt = "tbl")
colnames(taxa_info) <- paste0(colnames(taxa_info), "_1")
edges_df <- edges_df %>%
left_join(taxa_info, by = c("from" = "taxa_id_1"))
# Ensure the network is available
if (is.null(object@netw)) {
stop("The mgnet object does not contain a network.")
}
# Extract edge list with weights
net <- netw(object)
edges_df <- igraph::as_data_frame(net, what = "edges")
# If the network has weights, include them
if ("weight" %in% igraph::is_weighted(net)) {
edges_df$weight <- igraph::E(net)$weight
}
# Check if the network is directed
directed <- igraph::is.directed(net)
colnames(edges_df)[1:2] <- c("node1", "node2")
edges_df
colnames(edges_df)[1:2] <- c("node1", "node2")
taxa_info <- taxa(object, .fmt = "tbl")
colnames(taxa_info) <- paste0(colnames(taxa_info), "_1")
edges_df <- edges_df %>%
left_join(taxa_info, by = c("from" = "taxa_id_1"))
colnames(edges_df)[1:2] <- c("node1", "node2")
taxa_info <- taxa(object, .fmt = "tbl")
colnames(taxa_info) <- paste0(colnames(taxa_info), "_1")
edges_df <- edges_df %>%
left_join(taxa_info, by = c("node1" = "taxa_id_1"))
taxa_info <- taxa(object, .fmt = "tbl")
colnames(taxa_info) <- paste0(colnames(taxa_info), "_2")
edges_df <- edges_df %>%
left_join(taxa_info, by = c("node2" = "taxa_id_2"))
View(edges_df)
mgnet_edge_list(subjects_HMP2_netw)
mgnet_edge_list(subjects_HMP2_netw) %>% View
object <- subjects_HMP2_netw
purrr::map(object, mgnet_edge_list)
purrr::map(object, mgnet_edge_list) %>%
purrr::imap(\(x, y) {
x <- dplyr::mutate(x, mgnet = y, .before = 1)
})
purrr::map(object, mgnet_edge_list) %>%
purrr::imap(\(x, y) {
x <- dplyr::mutate(x, mgnet = y, .before = 1)
}) %>%
purrr::list_rbind()
# Apply edge list extraction to each mgnet in the list
purrr::map(object, mgnet_edge_list) %>%
purrr::imap(\(x, y) {
x <- dplyr::mutate(x, mgnet = y, .before = 1)
}) %>%
purrr::list_rbind() -> pl
View(pl)
object <- subjects_HMP2_netw
by = list("A" = c("69-001", "69-001"), c("69-001", "69-053"))
ifelse(nzchar(names(by)), names(by), sapply(by, function(x) paste(x, collapse = "-")))
merge_mgnets(subjects_HMP2_netw)
merge_mgnets(subjects_HMP2_netw@mgnets)
merge_mgnets(as.list(object), abun = abun, rela = rela, norm = norm,
meta = meta, taxa = taxa, netw = netw, comm = comm)
by
seq_len(by)
seq_along(by)
subjects_HMP2_netw[c("69-001", "69-001")]
mgnets(subjects_HMP2_netw[c("69-001", "69-001")])
mgnets(subjects_HMP2_netw)[c("69-001", "69-001")]
i <- 1
sub_object <- mgnets(object)[by[[i]]]
mgnet_collapse(subjects_HMP2_netw)
mgnet_collapse(subjects_HMP2_netw)
mgnet_collapse(subjects_HMP2_netw)
mgnet_collapse(subjects_HMP2_netw, abun = bind_rows)
mgnet_collapse(subjects_HMP2_netw, abun = bind_rows, by = list("A" = c("69-001", "69-001"), c("69-001", "69-053")))
mgnet_collapse(subjects_HMP2_netw, abun = bind_rows, by = list("A" = c("69-001", "69-053"), c("69-001", "69-053")))
help(cor)
cor(otu_HMP2)
help("on.exit")
data(HMP2)
subjects_HMP2_netw %>%
constructCorrCLRNet(thresh_method = "absolute", thresh_value = .3)
subjects_HMP2_netw %>%
constructCorrCLRNet(thresh_method = "absolute", thresh_value = .3, cores = 2)
subjects_HMP2_netw %>%
constructCorrCLRNet(thresh_method = "p-value", thresh_value = .05, cores = 2,
padj_method = "fdr")
subjects_HMP2_netw %>%
constructCorrCLRNet(thresh_method = "p-value", thresh_value = .01, cores = 2,
padj_method = "fdr")
subjects_HMP2_netw %>%
constructCorrCLRNet(thresh_method = "p-value", thresh_value = .01, cores = 2,
padj_method = "fdr")
help(unite)
setGeneric("unite_meta", function(object, col, ..., sep = "_", remove = TRUE) {
standardGeneric("unite_meta")
})
setMethod("unite_meta", "mgnet", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (length(meta(object)) == 0) stop("No meta data available in 'mgnet' object.")
# Use dplyr to unite columns
meta(object) <- dplyr::unite(meta(object, .fmt = "tbl"), col, ..., sep = sep, remove = remove) %>%
column_to_rownames("sample_id")
# Return the modified object
return(object)
})
setMethod("unite_meta", "mgnetList", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (any(length(meta(object)) == 0)) stop("No meta data available in 'mgnetList' object.")
# Use dplyr to unite columns
meta_merged <- dplyr::unite(meta(object, .fmt = "tbl"), col, ..., sep = sep, remove = remove)
meta_splitted <- meta_merged %>%
base::split(.[, "mgnet"]) %>%
purrr::imap(\(x,y){
dplyr::arrange(x, match(sample_id, sample_id(object[[y]])))
}) %>%
purrr::map(\(x){
x %>% dplyr::select(-"mgnet") %>%
tibble::column_to_rownames("sample_id")
})
meta_splitted <- meta_splitted[names(object)]
meta(object) <- meta_splitted
# Return the modified object
return(object)
})
HMP2 %>%
unite_meta("daje", SubjectID, Cl4_2)
help(unite)
setGeneric("unite_meta", function(object, col, ..., sep = "_", remove = TRUE) {
standardGeneric("unite_meta")
})
setMethod("unite_meta", "mgnet", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (length(meta(object)) == 0) stop("No meta data available in 'mgnet' object.")
# Use dplyr to unite columns
meta(object) <- tidyr::unite(meta(object, .fmt = "tbl"), col, ..., sep = sep, remove = remove) %>%
column_to_rownames("sample_id")
# Return the modified object
return(object)
})
setMethod("unite_meta", "mgnetList", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (any(length(meta(object)) == 0)) stop("No meta data available in 'mgnetList' object.")
# Use dplyr to unite columns
meta_merged <- tidyr::unite(meta(object, .fmt = "tbl"), col, ..., sep = sep, remove = remove)
meta_splitted <- meta_merged %>%
base::split(.[, "mgnet"]) %>%
purrr::imap(\(x,y){
dplyr::arrange(x, match(sample_id, sample_id(object[[y]])))
}) %>%
purrr::map(\(x){
x %>% dplyr::select(-"mgnet") %>%
tibble::column_to_rownames("sample_id")
})
meta_splitted <- meta_splitted[names(object)]
meta(object) <- meta_splitted
# Return the modified object
return(object)
})
HMP2 %>%
unite_meta("daje", SubjectID, Cl4_2)
HMP2 %>%
unite_meta("daje", SubjectID, CL4_2)
HMP2 %>%
unite_meta("daje", SubjectID, CL4_2) %>%
meta
setGeneric("unite_meta", function(object, col, ..., sep = "_", remove = TRUE) {
standardGeneric("unite_meta")
})
setMethod("unite_meta", "mgnet", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (length(meta(object)) == 0) stop("No meta data available in 'mgnet' object.")
# Use dplyr to unite columns
meta(object) <- tidyr::unite(meta(object, .fmt = "tbl"), {{col}}, ..., sep = sep, remove = remove) %>%
column_to_rownames("sample_id")
# Return the modified object
return(object)
})
setMethod("unite_meta", "mgnetList", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (any(length(meta(object)) == 0)) stop("No meta data available in 'mgnetList' object.")
# Use dplyr to unite columns
meta_merged <- tidyr::unite(meta(object, .fmt = "tbl"), col, ..., sep = sep, remove = remove)
meta_splitted <- meta_merged %>%
base::split(.[, "mgnet"]) %>%
purrr::imap(\(x,y){
dplyr::arrange(x, match(sample_id, sample_id(object[[y]])))
}) %>%
purrr::map(\(x){
x %>% dplyr::select(-"mgnet") %>%
tibble::column_to_rownames("sample_id")
})
meta_splitted <- meta_splitted[names(object)]
meta(object) <- meta_splitted
# Return the modified object
return(object)
})
HMP2 %>%
unite_meta("daje", SubjectID, CL4_2) %>%
meta
HMP2 %>%
unite_meta("daje", SubjectID, CL4_2) %>%
meta %>% View()
HMP2 %>%
unite_meta("daje", SubjectID, CL4_2, remove = FALSE) %>%
meta %>% View()
subjects_HMP2_netw %>%
unite_meta("daje", SubjectID, CL4_2, remove = FALSE) %>%
meta("tbl") %>% View()
setGeneric("unite_meta", function(object, col, ..., sep = "_", remove = TRUE) {
standardGeneric("unite_meta")
})
setMethod("unite_meta", "mgnet", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (length(meta(object)) == 0) stop("No meta data available in 'mgnet' object.")
# Use dplyr to unite columns
meta(object) <- tidyr::unite(meta(object, .fmt = "tbl"), {{col}}, ..., sep = sep, remove = remove) %>%
column_to_rownames("sample_id")
# Return the modified object
return(object)
})
setMethod("unite_meta", "mgnetList", function(object, col, ..., sep = "_", remove = TRUE) {
# Check if meta data exists
if (any(length(meta(object)) == 0)) stop("No meta data available in 'mgnetList' object.")
# Use dplyr to unite columns
meta_merged <- tidyr::unite(meta(object, .fmt = "tbl"), {{col}}, ..., sep = sep, remove = remove)
meta_splitted <- meta_merged %>%
base::split(.[, "mgnet"]) %>%
purrr::imap(\(x,y){
dplyr::arrange(x, match(sample_id, sample_id(object[[y]])))
}) %>%
purrr::map(\(x){
x %>% dplyr::select(-"mgnet") %>%
tibble::column_to_rownames("sample_id")
})
meta_splitted <- meta_splitted[names(object)]
meta(object) <- meta_splitted
# Return the modified object
return(object)
})
install.packages("Parallel")
